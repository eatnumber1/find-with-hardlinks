#!/bin/zsh
# find-with-hardlinks lists all the files in "target" directories, and
# additionally lists all the hardlinks to files in the target directories found
# within given "search" directories.
#
# This is useful for e.g. moving files and all their hardlinks between
# https://github.com/trapexit/mergerfs branches.
#
# The tool requires the following to be installed:
#
#  * https://www.zsh.org/
#  * https://github.com/tavianator/bfs
#  * https://github.com/dimo414/bkt (optional)

#set -x

setopt err_exit err_return
setopt warn_create_global no_unset
setopt pipe_fail

readonly PROGNAME="${0:t}"

zmodload -F zsh/zutil +b:zparseopts
zmodload -F zsh/files +b:rm

if [[ ! -v BKT_TTL ]]; then
  echo "Install https://github.com/dimo414/bkt and set BKT_TTL for cache-rerun speedup" >&2
  function bkt {
    while [[ "$1" != "--" ]]; do
      shift
    done
    shift
    "$@"
  }
fi

# Set BKT_CACHE_DIR so we won't save bkt outputs to TMPDIR after we override it.
BKT_CACHE_DIR="${BKT_CACHE_DIR:-${BKT_TMPDIR:-${TMPDIR:-/tmp}}}"
TMPDIR="$(mktemp --tmpdir -d "$PROGNAME".XXXXXXX)"
trap 'rm -rf -- "$TMPDIR"' EXIT

declare -a flag_help flag_search_dir flag_print0 flag_inode_sort
zparseopts -E -D -F -K -- \
  {h,-help}=flag_help \
  {s,-search_dir}+:=flag_search_dir \
  {0,-print0}=flag_print0 \
  {i,-inode_sort}=flag_inode_sort

function usage_and_die {
  echo "$(<< EOF
Usage: $PROGNAME [options] -- [additional find args] -- target_dirs...

Search for hardlinks to all files in the directories, listing all files in the
target directory and all hardlinks in the search dirs.

Args:
  additional find args - Additional args to pass to find when traversing target_dirs.
  dirs - The directories of files to search for hardlinks of.

Options:
  -h, --help - Print the help message
  -s, --search_dir dir - The directory to search for hardlinks. Can be repeated.
  -0, --print0 - Outputs files null-delimited.
  -i, --inode_sort - Sort the output by inode number.

All search dirs and target dirs must share a mountpoint, and $PROGNAME must be
run from the root of the mountpoint.

Example:
  cd /; find-with-hardlinks -i0 -s /home/myuser/tmp/dira -- -name c -- /home/myuser/tmp/dirb
EOF
  )"
  exit "${1:-1}"
}

if (( $#flag_help )); then
  usage_and_die
fi

if [[ $# -lt 3 || "$1" != "--" ]]; then
  usage_and_die 1 >&2
fi
shift  # removes '--'

declare -a findargs
while [[ $# -ne 0 && "$1" != "--" ]]; do
  findargs+=( "$1" )
  shift
done

if [[ "$1" != "--" ]]; then
  usage_and_die 1 >&2
fi
shift  # removes '--'

declare -a target_dirs
target_dirs=( "$@" )

# Get the value portion of an array-style flag parsed via zparseopts.
# zparseopts parses repeated flags into ary=( -f a -f b -f c ), this function
# will return ( a b c ).
#
# Usage: get_flag_values flag_ary_name out_ary_name
function get_flag_values {
  local -i i
  local flag_ary_name="$1" out_ary_name="$2"
  eval "${(q)out_ary_name}=()"
  for (( i = 2; i <= ${(P)#flag_ary_name}; i += 2 )); do
    eval "${(q)out_ary_name}+=( \"\${${(q)flag_ary_name}[$i]}\" )"
  done
}

declare -a search_dirs
get_flag_values flag_search_dir search_dirs

if [[ ${#target_dirs} -eq 0 ]]; then
  echo "You must specify at least one target directory." >&2
  usage_and_die 1 >&2
fi
if [[ ${#search_dirs} -eq 0 ]]; then
  echo "You must specify at least one search directory." >&2
  usage_and_die 1 >&2
fi

# Check that all the paths we were provided exist on the same filesystem.
declare target_fs
function () {
  function get_filesystem_of {
    stat -c %m "$1"
  }

  local fs p
  for p in "${search_dirs[@]}" "${target_dirs[@]}"; do
    if [[ ! -e "$p" ]]; then
      echo "Path $p does not exist" >&2
      usage_and_die 1 >&2
    fi

    fs="$(get_filesystem_of "$p")"

    if [[ -z "$target_fs" ]]; then
      target_fs="$fs"
      continue
    fi

    if [[ "$target_fs" != "$fs" ]]; then
      echo "All search and target dirs must be on the same filesystem" >&2
      usage_and_die 1 >&2
    fi
  done

  unfunction get_filesystem_of
}

# Because we have to output paths relative to the mountpoint, this tool must be
# run from the mountpoint. We don't cd into it to preserve find-like behavior
# where the output files always exist relative to the invoker's cwd.
if [[ "$PWD" != "$target_fs" ]]; then
  echo "$PROGNAME must be invoked from the root of a mountpoint (cd to $target_fs and try again)" >&2
  usage_and_die 1 >&2
fi

function canonicalize_paths_stdin {
 parallel -0Xq -- realpath \
   --no-symlinks --canonicalize-existing \
   --zero --relative-to="$target_fs" \
   --
}

target_files="$TMPDIR/target_files.txt"

bkt --cwd -- bfs -S dfs -O4 \
  -xdev -type f \
  "${findargs[@]}" \
  -printf '%i\t%p\0' \
  -- "${target_dirs[@]}" \
  > "$target_files"

function list_hardlinks {
  function select_inodes_of_target_files {
    function list_inodes_of_target_files {
      cut \
        --zero-terminated --delimiter=$'\t' \
        --fields=1 -- "$target_files" \
      | tr '\0' '\n'
    }

    # Via || : we ignore errors from grep because an empty input is an error,
    # which occurs if there are no files in the hardlink dirs.
    #
    # Per https://www.gnu.org/software/grep/manual/grep.html#Performance,
    # LC_ALL='C' can improve grep performance, and since we're just looking
    # for numbers, wide characters is not a concern (even if present, as long
    # as they don't contain embedded nulls, which isn't allowed in UTF-8).
    # https://stackoverflow.com/questions/6907297/can-utf-8-contain-zero-byte
    LC_ALL='C' grep \
      --null-data \
      --fixed-strings --line-regexp \
      --after-context=1 --no-group-separator \
      --file=<(list_inodes_of_target_files) \
    || :

    unfunction list_inodes_of_target_files
  }

  function merge_every_other_line {
    awk 'BEGIN { RS = "\0" } { getline b; printf("%s%s\0",$0,b) }'
  }

  # Usage: canonicalize_target_dir_for_expr dir
  # Returns:
  #   appends to array `retary`
  function canonicalize_target_dir_for_expr {
    local search_dir target_dir resolved
    # The find expression must be relative to a start point (one of the
    # search_dirs), but we don't know which it will be. So we generate paths
    # for all of them.
    for search_dir in "${search_dirs[@]}"; do
      for target_dir in "$@"; do
        resolved="$(realpath \
          --no-symlinks --canonicalize-missing \
          --relative-to="$search_dir" \
          -- "${target_dir}")"
        resolved="$search_dir/$resolved"
        if ([[ ! -e "$resolved" ]]) continue
        retary+=( "$resolved" )
      done
    done
  }

  local -a target_dir_exprs
  function () {
    local p v
    local -a retary
    for p in "${target_dirs[@]}"; do
      canonicalize_target_dir_for_expr "$p"
      for v ("${retary[@]}") target_dir_exprs+=( -o -path "$v" )
    done
  }

  # Find hardlinks
  #
  # This works by printing the inode number then the file path on subsequent
  # lines, then grepping for the inode number with one line of after context.
  # Then later we use awk to merge the two lines together.
  #
  bkt --cwd -- bfs -S dfs -O4 \
    -exclude "(" -false "${target_dir_exprs[@]}" ")" \
    -xdev -type f \
    -links +1 \
    -printf '%i\0\t%p\0' \
    -- "${search_dirs[@]}" \
  | select_inodes_of_target_files \
  | merge_every_other_line

  unfunction select_inodes_of_target_files merge_every_other_line canonicalize_target_dir_for_expr
}

function list_all_files {
  if (( $#flag_inode_sort )); then
    function inode_sort {
      sort --zero-terminated --numeric-sort --key=1 \
      | uniq --zero-terminated
    }
  else
    function inode_sort {
      cat
    }
  fi

  if (( $#flag_print0 )); then
    function convert_for_printing {
      cat
    }
  else
    function convert_for_printing {
      tr '\0' '\n'
    }
  fi

  local coproc_fd coproc_pid
  coproc list_hardlinks
  coproc_pid="$!"
  exec {coproc_fd}<&p

  cat -- /proc/$$/fd/${coproc_fd} "$target_files" \
  | inode_sort \
  | cut --zero-terminated --delimiter=$'\t' --fields=2- \
  | canonicalize_paths_stdin \
  | convert_for_printing

  exec {coproc_fd}<&-
  wait "$coproc_pid"

  unfunction inode_sort convert_for_printing
}
list_all_files
